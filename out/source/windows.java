/* autogenerated by Processing revision 1292 on 2023-07-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.Color;
import org.aec.facade.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class windows extends PApplet {


AEC aec;

Window window;
Window window2;


float counterMaxMS = 5000;
int counter = 0;
float t = 0;
int counterMaxFrames;





Life life;
Facade facade;


public void setup() {

  noiseDetail(1,0.5f);



  frameRate(25);
  /* size commented out by preprocessor */;
  
  PVector size = new PVector(10, 23);
  PVector origin = new PVector(30, 2);
  PVector spacing = new PVector(1,1);
  window = new Window(spacing,2, size, origin);

  size = new PVector(5, 5);
  origin = new PVector(20, 2);
  spacing = new PVector(1,1);
  window2 = new Window(spacing,5, size, origin);

  aec = new AEC();
  aec.init();


  counterMaxFrames = toFrames(counterMaxMS);

  // window.shiftGradient(CLOSE);

  PVector lifeOrigin = new PVector(10,10);
  PVector circleDist = new PVector(5,5);
  life = new Life(lifeOrigin, circleDist);

  facade = new Facade();
  facade.fill();


}




PVector faceSize = new PVector(10,24);




public void draw() {
  aec.beginDraw();  
  background(0, 0,0);
  noStroke();


  if (counter == 0) {
    life.begin();
  }


  // life.draw();
  facade.animate();
  facade.draw();


  noFill();
  rect(10,10,1,1);






  // window._fill(255,0,0);


  float level = map(counter, 0, counterMaxFrames, 10, 1);
  // int spacingY = int(map(counter, 0, counterMaxFrames, 1, 0.0));
  // println(spacingY);
  // window.updateLevels(int(level));
  window.updateSpacing(1,2);
  window2.updateSpacing(1,2);


  t = easeInOutSine(t);

  aec.endDraw();
  aec.drawSides();

  t++;
  counter++;
}


public float noiseLoop(float x,float y,float theta) {
  float rad = 1;
  float sc = 1; 
  float offset = 10; // parameters for the noise
  return noise(
    x*sc,
    y*sc+counter*.01f
  );

}

// from easings.net
public float easeInOutSine(float x) {
	return -(cos(PI * x) - 1) / 2;
}

public void keyPressed() {
  aec.keyPressed(key);
}




class AEC {
  AECPlugin plugin = new AECPlugin();
  HouseDrawer house = new HouseDrawer(plugin);
  
  public AEC() {
  }

  public void init() {
    plugin.setFrameWidth(width);
    plugin.init();
    loadConfig();
  }
    
  public void loadConfig() {
    plugin.loadConfig();
  }
  
  public void beginDraw() {
    scale(2 * plugin.scale, plugin.scale);
  }
  
  public void endDraw() {
    // reset of the transformation
    resetMatrix();
    
    loadPixels();
    plugin.update(pixels);
  }
  
  public void drawSides() {
    house.draw();
  }
  
  public void keyPressed(int value) {
    plugin.keyPressed(value, keyCode);
    
    if (value == 'i') {
      house.toggleIds();
    }
  }

  public void setActiveColor(Color c) {
    plugin.setActiveColor(c);
  }

  public void setInActiveColor(Color c) {
    plugin.setInActiveColor(c);
  }
  
  public int getScaleX() {
    return 2 * plugin.scale;
  }
  
  public int getScaleY() {
    return plugin.scale;
  }  
}

class Facade {

    int boundX = 40;
    int boundY = 22;

    int[][] pixels;
    
    ArrayList<Hole> holes;

    int frameCount = 0;

    Facade() {
        pixels = new int[boundX][boundY];
        holes = new ArrayList<Hole>();
    }

    public void fill() {

        for (int i = 0; i < boundX; i++) {
            for (int j = 0; j < boundY; j++) {
                this.pixels[i][j] = color(255,255,255);
            }
        }

    }

    public void addRandomHole() {
        Hole _hole = new Hole();
        holes.add(_hole);
    }

    public void addHole(int x, int y) {
        Hole _hole = new Hole();
        _hole.pos = new PVector(x,y);
    }

    public void addHole(Hole hole) {
        holes.add(hole);
    }

    public void draw() {

        for (int i = 0; i < boundX; i++) {
            for (int j = 0; j < boundY; j++) {
                pixel(i,j,pixels[i][j]);
            }
        }

        for (Hole hole : this.holes) {
            hole.draw();
        }


    }

    public void animate() {

        if (frameCount==0) {
            Hole hole = new Hole();
            hole.size = new PVector(5,5);
            hole.fadeIn();
            this.addHole(hole);  
        }

        // if (frameCount==toFrames(5000)) {
        //     Hole hole = holes.get(holes.size()-1);
        //     PVector velocity = new PVector(-5,0);
        //     hole.move(addVector(hole.size,velocity));
        // }


        frameCount++;
    }


}


class Hole {
    PVector pos;
    PVector size;

    Boolean closed;
    Boolean active;

    Boolean fadeIn = false;
    Boolean fadeOut = false;

    int frameCount = 0;
    int fadeTimeMS = 1000;
    int fadeTimeFrames;


    Hole() {
        this.pos = new PVector(random(40), random(22));
        this.size = new PVector(1,1);

        this.fadeTimeFrames = toFrames(fadeTimeMS);
    }

    public void close() {
        this.size = new PVector(0,0);
        this.closed = true;
    }

    public void draw() {

        int c = color(0,0,0);
        if (fadeIn) {
            float fadeAmount = map(frameCount, 0, fadeTimeFrames, 255, 0);
            c = color(fadeAmount);
        }
        else if (fadeOut) {
            float fadeAmount = map(frameCount, 0, fadeTimeFrames, 0, 255);
            c = color(fadeAmount); 
        }
        for (int i = 0; i < PApplet.parseInt(size.x); i++) {
            for (int j = 0; j < PApplet.parseInt(size.y); j++) {
                facade.pixels[i+PApplet.parseInt(pos.x)][j+PApplet.parseInt(pos.y)] = c;
            }
        }



        frameCount++;
        if (frameCount>=fadeTimeFrames) {
            println("done");
            fadeOut = false;
            fadeIn = false;
            frameCount = 0;
        }
    }

    public void fadeIn() {
        this.fadeIn = true;
    }

    public void fadeOut() {
        this.fadeOut = true;
    }

    public void move(PVector _newSize) {
        this.size = _newSize;
    }

    // void expand(pos ) {

    // }

}

class HouseDrawer {
  AECPlugin aec;
  int size = 10;  
  PFont font;
  boolean showIds = false;
  
  public HouseDrawer(AECPlugin aec_) {
    aec = aec_;
    font = loadFont("LucidaConsole-8.vlw"); 
  }
  
  public void toggleIds() {
    showIds = !showIds;
  }
  
  public void draw() {
    resetMatrix();
    
    for (int i = 0; i < Building.SIDE.values().length; ++i) {
      Building.SIDE sideEnum = Building.SIDE.values()[i];
      Side side = aec.getSide(sideEnum);
      
      stroke(side.getColor().getRed(), side.getColor().getGreen(), side.getColor().getBlue(), side.getColor().getAlpha());
      noFill();
      drawSide(side);     
    }
  }
  
  public void drawSide(Side s) {
    int[][] adr = s.getWindowAddress();
    int pWidth = s.getPixelWidth();
    int pHeight = s.getPixelHeight();

    for (int y = 0; y < adr.length; ++y) {
      for (int x = 0; x < adr[y].length; ++x) {
        if (adr[y][x] > -1) {
          int fx = (s.getX() + x * pWidth) * aec.scale;
          int fy = (s.getY() + y * pHeight) * aec.scale;
          rect(fx, fy, pWidth * aec.scale, pHeight * aec.scale);
          
          if (showIds) {
            textFont(font, 8); 
            text("" + adr[y][x], fx + pWidth * aec.scale / 4, fy + pHeight * aec.scale * 0.9f);
          }
        }
      }
    }
  }
}


class Life {
    
    PVector origin;
    PVector dist;


    Circle ballM;
    Circle ballF;

    int ballRadius;
    float ballSpeed = 0.5f;
    Boolean ballsMorphing = false;
    Boolean ballsBeating = false;
    Boolean bloodAnimation = false;

    int frameCount;
    boolean running;


    Life(PVector _origin, PVector _dist) {
        this.origin = _origin;
        this.dist = _dist;

        this.ballRadius = 3;
    }  

    public void begin() {
        this.frameCount = 0;
        this.running = true;
        
        PVector posF = this.origin.copy().add(this.dist.copy());
        PVector posM = this.origin.copy().sub(this.dist.copy());

        ballF = new Circle(PApplet.parseInt(posF.x), PApplet.parseInt(posF.y), this.ballRadius, color(255,0,0));
        ballM = new Circle(PApplet.parseInt(posM.x), PApplet.parseInt(posM.y), this.ballRadius, color(0,0,255));

        this.ballsMorphing = true;
    }  


    public void draw() {



        if (ballF.x == ballM.x && ballF.y == ballM.y && ballsMorphing) {
            ballsMorphing = false;
            int mixedColor = this.ballM.c + this.ballF.c;
            this.ballM.updateColor(mixedColor);
            this.ballF.updateColor(mixedColor);
        }

        PVector ballVelocity = new PVector(1,1);
        if (ballsMorphing) {
            ballM.move(ballVelocity);
            ballF.move(ballVelocity.mult(-1));

            ballF.draw();
            ballM.draw();
        }
        else {
            ballF.beat();
            ballM.beat();
            ballF.draw(false);
            ballM.draw(false);
        }



        frameCount++;
    }
}
class Circle {
    
    int x;
    int y;
    int r;
    float morphedRadius;

    int c;

    int numVertices;
    ArrayList<PVector> vertices;

    int frameCount = 0;
    int bpm;
    int beatCounter = 0;

    Circle(int _x, int _y, int _r, int _c) {
        this.x = _x;
        this.y = _y;
        this.r = _r;
        this.c = _c;

        this.numVertices = 20;
        this.vertices = new ArrayList<PVector>();
    }

    public void draw(Boolean regen) {
        if (regen) {
            createVertices();
        }

        println("drawing");

        // ellipse(this.x, this.y, this.r, this.r);

        fill(this.c);
        beginShape();
        for (PVector pos : this.vertices) {
            vertex(this.x+pos.x,this.y+pos.y);
        }
        endShape(CLOSE);
    }

    public void draw() {
        createVertices();

        println("drawing");

        // ellipse(this.x, this.y, this.r, this.r);

        fill(this.c);
        beginShape();
        for (PVector pos : this.vertices) {
            vertex(this.x+pos.x,this.y+pos.y);
        }
        endShape(CLOSE);

        frameCount++;
    }

    public void createVertices() {
        float theta = 0;
        float deltaTheta = TAU/numVertices;
        this.vertices = new ArrayList<PVector>();
        for (int i = 0; i < numVertices; i++) {
            PVector _pos = new PVector(cos(theta), sin(theta));
            _pos.mult(this.r);
            this.vertices.add(_pos);
            theta += deltaTheta;
        }
    }

    public void move(PVector vel) {
        this.x+=PApplet.parseInt(vel.x);
        this.y+=PApplet.parseInt(vel.y);
    }

    public void updateColor(int _c) {
        this.c = _c;
    }

    public void morph(float _amnt) {
        // morphs each vertex using perlin noise based on an amount from 0-1


        float theta = 0;
        float deltaTheta = TAU/numVertices;
        this.vertices = new ArrayList<PVector>();
        for (int i = 0; i < numVertices; i++) {
            PVector _pos = new PVector(cos(theta), sin(theta));
            float n = noise(i*.001f, frameCount+0.001f)*_amnt;
            float radius = n*this.r;
            println(radius);
            _pos.mult(radius);
            this.vertices.add(_pos);
            theta += deltaTheta;
        }
    }

    public void beat() {
        beatCounter++;
        if (beatCounter==0) {
            beatCounter = 0;
        }
        if (beatCounter>=bpm) {
            println("beat");
            beatCounter=0;
            // this.colorB
        }

    }




}
int CLOSE = 0;
int OPEN = 1;

class Window {
  
  PVector origin;
  PVector size;
  PVector pos;
  int spacingX;
  int spacingY;
  int max_level;
  
  PVector v;
  
    int transparency = 255;
    float[] max_color = {0,0,0};
    // float[] max_color = {255,255,0};
    float[] min_color = {255,255,255};
    // float[] min_color = {255,0,0};
    // float[] min_color = {255,0,0};

    float[] axisBounds = {-1.0f, 1.0f};

    // closer to max_levels = open, closer to 0 = closed
    int gradientPos;
    
    
    int color_array_idx = 0;
    int color_array_size = 3;
    int[][] color_array = {
        {255,0,0},
        {255,0,255},
        {0,255,0},
        {0,0,0}
    };
    
    int fade_counter = 0;
    int fade_counter_max = 100;
    
    int shapeMode;
 
  Window(PVector _spacing, int _numShapes, PVector _size, PVector _origin) {
    this.pos = new PVector(0,0);
    this.v = new PVector(random(.01f)+0.03f,random(0.01f)+0.05f);
    this.origin = _origin;
    
    int spacingX = PApplet.parseInt(_spacing.x);
    int spacingY = PApplet.parseInt(_spacing.y);
    this.max_level = _numShapes;
    
    this.shapeMode = ELLIPSE;
    this.size = _size;

    this.gradientPos = 0;
    
  }
  
  
  public void updatePos(float x, float y) {
    this.pos = new PVector(x,y);
  }
  
  public void updateV(float x, float y) {
    this.pos = new PVector(x,y);
  }
  
  // Draw Concentric Rectangles
  public void draw() {
    println(this.max_level);
    for (int i = 0; i < this.max_level; i++) {
      
      float[] c = {0,0,0};
      for (int channel = 0; channel < 3; channel++) {
        c[channel] = map(i, this.gradientPos, this.max_level, this.min_color[channel], this.max_color[channel]);
      }
      
      fill(c[0], c[1], c[2], transparency);
      int rect_width = PApplet.parseInt(this.size.x - this.spacingX*i*2);
      int rect_height = PApplet.parseInt(this.size.y - this.spacingY*i*2);
  
      rect(this.origin.x+i*this.spacingX+i*this.pos.x*this.spacingX, 
              this.origin.y+i*this.spacingY+(i*this.pos.y*this.spacingY), 
              rect_width, 
              rect_height);
    }
  }


  
  public void checkBoundaries() {
    // If we are past the bounds of either axis, change the direction of the velocity
    if (pos.x > axisBounds[1] || pos.x < axisBounds[0]) {
      this.v.x *= -1.0f;
    }
    if (pos.y > axisBounds[1] || pos.y < axisBounds[0]) {
      this.v.y *= -1.0f;
    } 
  }
  
  public void move() {
    this.pos.add(this.v);
    this.checkBoundaries();
  }
  
  public void fade() {
    int color_pos_start = color_array_idx;
    int color_pos_end = (color_array_idx+1)%color_array.length;
        
    for (int i = 0; i < 3; i++) {
      this.min_color[i] = map(
          this.fade_counter, 
          0, this.fade_counter_max, 
          this.color_array[color_pos_start][i], this.color_array[color_pos_end][i]
      );
    }
    fade_counter++;
    if (fade_counter >= fade_counter_max) {
      color_array_idx = (color_array_idx+1)%color_array.length;
      print(color_array_idx, "\n");
      fade_counter = 0;
    }
  }


  public void _fill(int r, int g, int b) {
    // Fill the window with a color 
    for (int i = 0; i < PApplet.parseInt(this.size.x); i++) {
        for (int j = 0; j < PApplet.parseInt(this.size.y); j++) {
            fill(r,g,b);
            rect(PApplet.parseInt(i+this.origin.x), PApplet.parseInt(j+this.origin.y), 1, 1);
        }
    }
  }

  public void close() {

  }

    public void shiftGradient(int direction) {
        if (direction==OPEN) {
            this.gradientPos=this.gradientPos+1;
        }
        else if (direction==CLOSE) {
            this.gradientPos=this.gradientPos-1;
        }
        else {
            println("direction doesn't exist");
        }

    }

  public void updateLevels(int _num) {
    this.max_level = _num;
  }

  public void updateSpacing(int _x, int _y) {
    this.spacingX = _x;
    this.spacingY = _y;
  }
  
  public void handleMousePressed() {
    this.pos.x = (mouseX - width/2) / PApplet.parseFloat(width);
    this.pos.y = (mouseY - height/2) / PApplet.parseFloat(height);
    
    if (this.shapeMode == RECT) {
      this.shapeMode = ELLIPSE;
    }
    else {
      this.shapeMode = RECT;
    }    
  }
}


// class Ripple() {
//     int x;
//     int y; 

//     // Ripple() {

//     // }



// }



public int toFrames(float _ms) {

    return PApplet.parseInt((_ms/1000)*frameRate);

}


public void pixel(int x, int y) {
    rect(x,y,1,1);
}

public void pixel(int x, int y, int c) {
    fill(c);
    rect(x,y,1,1);
}


public void pixel(float x, float y) {
    rect(x,y,1,1);
}


public PVector addVector(PVector a, PVector b) {
    PVector _tmp = new PVector(a.x+b.x,a.y+b.y);
    return _tmp;
}

public PVector subVector(PVector a, PVector b) {
    PVector _tmp = new PVector(a.x-b.x,a.y-b.y);
    return _tmp;
}


  public void settings() { size(1200, 400); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "windows" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
